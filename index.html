<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Mapbox GL JS map</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .map-overlay {
            display: none;
            font: 12px/20px Arial, sans-serif;
            padding: 10px;
            position: absolute;
            right: 0;
            top: 0;
            width: 230px;
            overflow: hidden;
            white-space: normal;
            transition: opacity 0.3s ease;
        }

        #zoom-level {
            position: absolute;
            bottom: 10px;
            left: 1000px;
            background: rgba(255, 255, 255, 0.8);
            padding: 6px 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-radius: 4px;
            z-index: 1;
            user-select: none;
            pointer-events: none;
            /* so it doesn’t interfere with map interaction */
        }

        .card-title {
            font-family: Arial, sans-serif;
            /* Example font */
            font-size: 30px;
            /* Larger font size */
            font-weight: bold;
            /* Bold text */
            color: #2a2a2a;
            /* Darker color */
            /* add other styles like text-transform, letter-spacing, etc. */
        }

        .map-overlay-inner {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 25vw;
            height: 96vh;
            font-family: Arial, sans-serif;
            font-size: 15px;
            line-height: 1.5;
            overflow-y: auto;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, .5);
            z-index: 9999;
            box-sizing: border-box;
            transition: height 0.2s ease;
            touch-action: none;
        }

        .card-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
        }

        /* Responsive override for mobile screens */
        @media (max-width: 768px) {
            .map-overlay-inner {
                top: auto;
                /* unset top */
                bottom: 0;
                /* align to bottom */
                left: 0;
                overflow-y: auto;
                width: 100vw;
                /* full screen width */
                height: 30vh;
                /* bottom half */
                border-radius: 8px 8px 0 0;
                /* rounded top corners */
            }
        }

        .subtitle-main {
            font-size: 1.3em;
            font-weight: 500;
            color: #333;
            margin-top: 4px;
        }

        .subtitle-region {
            font-size: 1.2em;
            font-style: italic;
            color: #666;
            margin-bottom: 4px;
        }

        #filter-toggle-btn {
            position: absolute;
            top: 10px;
            right: 50px;
            background: #fff;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 1;
            border: none;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .hydro-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .hydro-button:hover {
            background: #f0f0f0;
        }


        #filter-toggle-btn:hover {
            background-color: #f0f0f0;
        }

        #filter-toggle-btn:active {
            transform: translateY(1px);
        }

        .map-overlay-drag-handle {
            width: 60px;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
            margin: 8px auto;
            touch-action: none;
            cursor: grab;
        }

        #menu {
            position: absolute;
            background: #fff;
            padding: 10px;
            font-family: Arial, sans-serif;
            z-index: 1;
            top: 10px;
            right: 150px;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            background: transparent;
            border: none;
            font-size: 24px;
            color: #333;
            cursor: pointer;
            z-index: 10000;
        }
    </style>
</head>

<body>

    <div id="map"></div>
    <!-- The rest of your content -->

    <div id="menu">
        <input id="satellite-streets-v12" type="radio" name="rtoggle" value="satellite">
        <label for="satellite-streets-v12">Satellite</label>
        <input id="outdoors-v12" type="radio" name="rtoggle" value="outdoors" checked="checked">
        <label for="outdoors-v12">Outdoors</label>
    </div>

    <button onclick="toggleFilters()" id="filter-toggle-btn"
        style="position: absolute; top: 10px; right: 50px; z-index: 1000;">
        Show Filters
    </button>

    <!-- Combined Filters Box (hidden by default) -->
    <div id="combined-filters"
        style="display: none; position: absolute; top: 60px; right: 50px; background: white; padding: 10px; z-index: 999; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); font-family: sans-serif; width: 220px;">

        <div id="method-filters" style="margin-bottom: 10px;">
            <strong style="font-size: 14px;">Filter waterway by method</strong><br>
            <label><input type="checkbox" value="fly" checked> Fly</label><br>
            <label><input type="checkbox" value="spin" checked> Spin</label><br>
            <label><input type="checkbox" value="bait" checked> Bait</label>
        </div>
        <div id="point-type-filter">
            <strong style="font-size: 14px;">Filter icon</strong><br>
            <label>
                <input type="checkbox" value="AccessPoint" checked>
                <img src="images/Revised-Dot-TW - Copy.png" alt="Access Point"
                    style=" height:16px; vertical-align:middle; margin-right:4px;">
                Access Point
            </label><br>
            <label>
                <input type="checkbox" value="hut" checked>
                <img src="images/Hut-Marker-Dot.png" alt="Hut"
                    style=" height:16px; vertical-align:middle; margin-right:4px;">
                Hut
            </label><br>
            <label>
                <input type="checkbox" value="FlyFishing" checked>
                <img src="images/Fly-Fishing-Marker-Dot.png" alt="Fly Fishing"
                    style=" height:16px; vertical-align:middle; margin-right:4px;">
                Fly Fishing
            </label><br>
            <label>
                <input type="checkbox" value="Hatchery" checked>
                <img src="images/Hatchery-Marker-Dot.png" alt="Hatchery"
                    style=" height:16px; vertical-align:middle; margin-right:4px;">
                Hatchery
            </label><br>
            <label>
                <input type="checkbox" value="DesignatedWater" checked>
                <img src="images/DesignatedWater.png" alt="Designated Water"
                    style="height:16px; vertical-align:middle; margin-right:4px;">
                Designated Water
            </label><br>
            <label>
                <input type="checkbox" value="Trolling" checked>
                <img src="images/Trolling-Marker-Dot-1.png" alt="Trolling"
                    style="height:16px; vertical-align:middle; margin-right:4px;">
                Trolling
            </label><br>
            <label>
                <input type="checkbox" value="BoatRamp" checked>
                <img src="images/Boat-Launch-Marker-Dot.png" alt="Boat Ramp"
                    style=" height:16px; vertical-align:middle; margin-right:4px;">
                Boat Ramp
            </label>
        </div>

        <div style="margin-top: 10px;">
            <button id="toggle-fg-regions" style="padding: 6px 12px; font-size: 14px; cursor: pointer;">
                Hide FG Regions
            </button>
        </div>


    </div>


    <div id="zoom-level"></div>


    <div class="map-overlay" id="properties"></div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoiYmVhdWNoaWxkIiwiYSI6ImNtYWxuZTh4cTBhbm4yam9wb2N6OTZmc2YifQ._fwiw77G_XhZonhV5d3CJA';

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/outdoors-v12',
            center: [173.1, -41.4],
            minZoom: 5,
            zoom: 5
        });
        map.addControl(new mapboxgl.FullscreenControl());
        map.addControl(new mapboxgl.NavigationControl({
            showCompass: false
        }));
        map.addControl(new mapboxgl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            trackUserLocation: true,
            showUserHeading: true
        }));

        map.dragRotate.disable();


        // disable map rotation using touch rotation gesture
        map.touchZoomRotate.disableRotation();

        const card = document.getElementById('properties');
        const showCard = (feature) => {
            const props = feature.properties;
            const displayFields = {
                methods: 'Method',
                open: 'Open',
                limtrout: 'Trout Limit',
                Description: "Description",
            };

            let content = `
    <div class="map-overlay-inner">
        <div class="map-overlay-drag-handle"></div>
        <button class="close-button" onclick="document.getElementById('properties').style.display='none'">×</button>
        <code class="card-title">${props.name || props.Title || 'No Title'}</code>
    `;

            // Subtitle
            if (props.subtitle) {
                content += `<div class="card-subtitle subtitle-main">${props.subtitle}</div>`;
            }

            // Region
            if (props.Region) {
                content += `<div class="card-subtitle subtitle-region">${props.Region} Fish & Game Region</div>`;
            }

            content += `
    <hr>
    <ul class="card-list">
`;


            for (const [key, label] of Object.entries(displayFields)) {
                if (props[key] !== undefined) {
                    content += `<li><b>${label}</b>: ${props[key]}</li>`;
                }
            }

            content += `</ul></div>`;
            card.innerHTML = content;
            card.style.display = 'block';
        };





        let selectedPoint = null;
        let selectedRiver = null;
        let selectedLake = null;
        let hoveredAccessPointId = null;
        let hoveredRiverId = null;
        let hoveredLakeId = null;
        let toggleIndex = 0; // 0 or 1, to switch between point and line
        // Before adding the layer, load and add your icon image:

        // Define your images in an array
        const customImages = [
            { name: 'AccessPoint-icon', url: 'images/Revised-Dot-TW - Copy.png' },
            { name: 'hut-icon', url: 'images/Hut-Marker-Dot.png' },
            { name: 'FlyFishing-icon', url: 'images/Fly-Fishing-Marker-Dot.png' },
            { name: 'Hatchery-icon', url: 'images/Hatchery-Marker-Dot.png' },
            { name: 'DesignatedWater-icon', url: 'images/DesignatedWater.png' },
            { name: 'Trolling-icon', url: 'images/Trolling-Marker-Dot-1.png' },
            { name: 'BoatRamp-icon', url: 'images/Boat-Launch-Marker-Dot.png' },
        ];

        // Function to load images
        function loadCustomImages(map, callback) {
            let imagesLoaded = 0;

            customImages.forEach(({ name, url }) => {
                map.loadImage(url, (error, image) => {
                    if (error) {
                        console.error(`Error loading image "${name}" from ${url}:`, error);
                        return;
                    }

                    if (!map.hasImage(name)) {
                        map.addImage(name, image);
                    }

                    imagesLoaded++;

                    // When all images are loaded, run the callback
                    if (imagesLoaded === customImages.length && typeof callback === 'function') {
                        callback();
                    }
                });
            });
        }

        // Initial map load
        map.on('load', () => {
            loadCustomImages(map, () => {
                addCustomDataAndLayers(); // only once all images are loaded
            });

        });

        // Style reload (after style change)
        map.on('style.load', () => {
            loadCustomImages(map, () => {
                addCustomDataAndLayers();
            });
        });
        function updateLayerFilter() {
            const checkboxes = document.querySelectorAll('#point-type-filter input[type="checkbox"]');
            const selectedTypes = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);

            const filter = ['in', ['get', 'point_type'], ['literal', selectedTypes]];
            map.setFilter('data-points-all', filter);
        }

        const zoomLevel = document.getElementById('zoom-level');

        // Set initial zoom text
        zoomLevel.textContent = `Zoom: ${map.getZoom().toFixed(2)}`;

        // Update zoom text when zoom changes
        map.on('zoom', () => {
            zoomLevel.textContent = `Zoom: ${map.getZoom().toFixed(2)}`;
        });

        // Attach change listeners to checkboxes
        const checkboxes = document.querySelectorAll('#point-type-filter input[type="checkbox"]');
        checkboxes.forEach(cb => cb.addEventListener('change', updateLayerFilter));

        function addCustomDataAndLayers() {
            const layers = map.getStyle().layers;
            let firstSymbolId;
            for (const layer of layers) {
                if (layer.type === 'symbol') {
                    firstSymbolId = layer.id;
                    break;
                }
            }

            
            map.addSource('PublicAccessAreas', {
                type: 'vector',
                url: 'mapbox://beauchild.PublicAccessAreas' // If using Mapbox
            });

            map.addLayer({
                id: 'PublicAccessAreas-fill',
                type: 'fill',
                source: 'PublicAccessAreas',
                minzoom: 12,
                'source-layer': 'mylayer',
                paint: {
                    'fill-color': [
                        'match',
                        ['get', 'DataType'],
                        'DOC Conservation Area', '#2d6c3e',        // blue
                        'Esplanade Reserve', '#66f0cb',            // green
                        'Esplanade Strip', '#ff66dc',              // pink
                        'Hydro Parcel', '#abecff',                  // red
                        'Non-Primary Parcel', '#ff7f00',            // orange
                        'Public Access Easement', '#ffd8f1',        // purple
                        'Reserve Land', '#a9cb66',                   // light green
                        'Road Parcel', '#cca3e1',                     // light blue
                        'Walkway Easement', '#ffb2b2',                 // yellow
                        /* default color if none match */
                        '#cccccc'
                    ],
                    'fill-opacity': [
                        'match',
                        ['get', 'DataType'],
                        'DOC Conservation Area', .5,        // blue
                        'Esplanade Reserve', .5,            // green
                        'Esplanade Strip', .5,              // pink
                        'Hydro Parcel', .5,                  // red
                        'Non-Primary Parcel', .1,            // orange
                        'Public Access Easement', .5,        // purple
                        'Reserve Land', .5,                   // light green
                        'Road Parcel', .5,                     // light blue
                        'Walkway Easement', .5,                 // yellow
                        /* default color if none match */
                        .5
                    ],
                }
            }, firstSymbolId);


            map.addSource('FG Regions', {
                type: 'geojson',
                data: 'FG_dissolved.geojson'
            });

            map.addLayer({
                id: 'FG Regions-line',
                type: 'line',
                source: 'FG Regions',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round',
                    visability:'none'
                },
                paint: {
                    'line-color': 'grey',
                    'line-width': 4,
                    'line-opacity': 0.6
                }
            }, firstSymbolId);

// Add your centroid points source
map.addSource('FG Region Centroids', {
  type: 'geojson',
  data: 'FG_region_centroids.geojson'  // your centroid GeoJSON file
});

// Add the label layer for the centroids
map.addLayer({
  id: 'FG Region Labels',
  type: 'symbol',
  source: 'FG Region Centroids',
  maxzoom: 7,
  layout: {
    'text-field': ['get', 'NAME'],       // use the NAME property
    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
    'text-size': 14,
    'text-anchor': 'center',
    'text-allow-overlap': false  ,
    visability:'none'       // prevents overlapping labels
  },
  paint: {
    'text-color': '#000000',
    'text-halo-color': '#ffffff',
    'text-halo-width': 1.5
  }
});


            map.addSource('AW Rivers', {
                type: 'geojson',
                data: 'AWRivers28May.geojson',
                generateId: true
            });



            map.addLayer({
                id: 'AW Rivers-line',
                type: 'line',
                source: 'AW Rivers',
                minzoom: 7,
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': [
                        'case',
                        ['boolean', ['feature-state', 'selected'], false],
                        '#7983ec',
                        ['boolean', ['feature-state', 'highlight'], false],
                        '#4ca6e6',
                        '#79bcec'
                    ],

                    'line-width': [
                        'case',
                        ['boolean', ['feature-state', 'selected'], false],
                        10,
                        ['boolean', ['feature-state', 'highlight'], false],
                        9,
                        6
                    ],
                    'line-opacity': .9
                }
            }, firstSymbolId);

            map.addSource('Lakes', {
                type: 'geojson',
                data: 'Lakes29May.geojson',
                generateId: true
            });

            map.addLayer({
                id: 'Lakes-poly',
                type: 'fill',
                source: 'Lakes',
                paint: {
                    'fill-color': [
                        'case',
                        ['boolean', ['feature-state', 'selected'], false],
                        '#7983ec',
                        ['boolean', ['feature-state', 'highlight'], false],
                        '#4ca6e6',
                        '#79bcec'
                    ],
                    'fill-opacity': .8
                }
            }, firstSymbolId);



            // Add the source

            map.addSource('Routes', {
                type: 'geojson',
                data: 'Routes.geojson',
            });

            map.addLayer({
                id: 'Routes-line',
                type: 'line',
                source: 'Routes',
                minzoom: 9,
                layout: {
                    // layout options go here (e.g., 'line-cap', 'line-join'), if needed
                },
                paint: {
                    'line-width': ['get', 'line_width'],
                    'line-color': ['get', 'line_color'],
                    'line-dasharray': ['get', 'line_dasharray']
                }
            });

            // Add the source
            map.addSource('data-points', {
                type: 'geojson',
                data: 'AccessAllRegions.geojson',
                generateId: true
            });

            // Layer for Access Points
            map.addLayer({
                id: 'data-points-all',
                type: 'symbol',
                source: 'data-points',
                minzoom: 10,
                layout: {
                    'icon-image': ['concat', ['get', 'point_type'], '-icon'],
                    'icon-size': 0.14,
                    'icon-anchor': ['get', 'anchor'],
                    'icon-allow-overlap': true
                }
            });




            // Create a popup div (not a Mapbox popup) and add to the map container
            const popup = document.createElement('div');
            popup.style.position = 'absolute';
            popup.style.pointerEvents = 'none';  // allow mouse events to pass through
            popup.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';  // semi-transparent black
            popup.style.color = '#fff';
            popup.style.fontFamily = 'Arial, sans-serif';
            popup.style.padding = '4px 8px';
            popup.style.borderRadius = '4px';
            popup.style.fontSize = '12px';
            popup.style.display = 'none';  // hidden initially
            document.body.appendChild(popup);

            map.on('mousemove', 'PublicAccessAreas-fill', (e) => {
                if (e.features.length > 0) {
                    const feature = e.features[0];
                    const dataType = feature.properties.DataType;

                    popup.style.display = 'block';
                    popup.textContent = dataType || 'No DataType';

                    popup.style.left = e.originalEvent.pageX + 10 + 'px';
                    popup.style.top = e.originalEvent.pageY + 10 + 'px';
                }
            });

            map.on('mouseleave', 'PublicAccessAreas-fill', () => {
                popup.style.display = 'none';
            });








            let selectedFeatureId = null;
            let hoverFeatureId = null;

            function updateIconSize() {
                // Access Points
                map.setLayoutProperty('data-points-all', 'icon-size', [
                    'case',
                    ['all', ['==', ['id'], hoverFeatureId], ['!=', ['id'], selectedFeatureId]], 0.15,
                    ['==', ['id'], selectedFeatureId], 0.18,
                    0.14
                ]);

            }

            // Hover start — only update if not the selected feature
            map.on('mouseenter', 'data-points-all', e => {
                map.getCanvas().style.cursor = 'pointer';

                const hoveredId = e.features[0].id;
                // Only apply hover if not currently selected
                if (hoveredId !== selectedFeatureId) {
                    hoverFeatureId = hoveredId;
                    updateIconSize();
                }
            });

            // Hover end — clear hover unless it's also selected
            map.on('mouseleave', 'data-points-all', () => {
                map.getCanvas().style.cursor = '';
                hoverFeatureId = null;
                updateIconSize();
            });


            // Click on an access point — select it
            map.on('click', 'data-points-all', e => {
                selectedFeatureId = e.features[0].id;
                hoverFeatureId = null; // Clear hover on selection
                updateIconSize();
            });

            // Click elsewhere — clear selection
            map.on('click', e => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['data-points-all']
                });

                if (features.length === 0 && selectedFeatureId !== null) {
                    selectedFeatureId = null;
                    updateIconSize();
                }
            });

            map.on('click', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['data-points-all', 'AW Rivers-line', 'Lakes-poly']
                });

                // Deselect previous selection
                if (selectedPoint) {
                    map.setFeatureState({ source: 'data-points', id: selectedPoint.id }, { selected: false });
                    selectedPoint = null;
                }
                if (selectedRiver) {
                    map.setFeatureState({ source: 'AW Rivers', id: selectedRiver.id }, { selected: false });
                    selectedRiver = null;
                }

                if (selectedLake) {
                    map.setFeatureState({ source: 'Lakes', id: selectedLake.id }, { selected: false });
                    selectedLake = null;
                }

                if (features.length === 0) {
                    card.style.display = 'none';
                    return;
                }

                // Prioritize selecting points over lines
                const pointFeature = features.find(f => f.layer.id === 'data-points-all');
                const riverFeature = features.find(f => f.layer.id === 'AW Rivers-line');
                const lakeFeature = features.find(f => f.layer.id === 'Lakes-poly');

                if (pointFeature) {
                    selectedPoint = pointFeature;
                    map.setFeatureState({ source: 'data-points', id: pointFeature.id }, { selected: true });
                    showCard(pointFeature);
                } else if (riverFeature) {
                    selectedRiver = riverFeature;
                    map.setFeatureState({ source: 'AW Rivers', id: riverFeature.id }, { selected: true });
                    showCard(riverFeature);
                }
                else if (lakeFeature) {
                    selectedLake = lakeFeature;
                    map.setFeatureState({ source: 'Lakes', id: lakeFeature.id }, { selected: true });
                    showCard(lakeFeature);
                }
            });



            let isHovering = {
                points: false,
                rivers: false,
                lakes: false
            };

            function updateCursor() {
                if (isHovering.points || isHovering.rivers || isHovering.lakes) {
                    map.getCanvas().style.cursor = 'pointer';
                } else {
                    map.getCanvas().style.cursor = '';
                }
            }


            map.on('mouseenter', 'data-points-all', (e) => {
                isHovering.points = true;
                updateCursor();

                const feature = e.features[0];
                if (hoveredAccessPointId !== null && hoveredAccessPointId !== feature.id) {
                    map.setFeatureState({ source: 'data-points', id: hoveredAccessPointId }, { highlight: false });
                }
                hoveredAccessPointId = feature.id;
                map.setFeatureState({ source: 'data-points-all', id: feature.id }, { highlight: true });
            });

            map.on('mouseleave', 'data-points-all', () => {
                isHovering.points = false;
                updateCursor();

                if (hoveredAccessPointId !== null) {
                    map.setFeatureState({ source: 'data-points', id: hoveredAccessPointId }, { highlight: false });
                    hoveredAccessPointId = null;
                }
            });



            map.on('mouseenter', 'AW Rivers-line', (e) => {
                isHovering.rivers = true;
                updateCursor();

                const feature = e.features[0];
                if (hoveredRiverId !== null && hoveredRiverId !== feature.id) {
                    map.setFeatureState({ source: 'AW Rivers', id: hoveredRiverId }, { highlight: false });
                }
                hoveredRiverId = feature.id;
                map.setFeatureState({ source: 'AW Rivers', id: feature.id }, { highlight: true });
            });

            map.on('mouseleave', 'AW Rivers-line', () => {
                isHovering.rivers = false;
                updateCursor();

                if (hoveredRiverId !== null) {
                    map.setFeatureState({ source: 'AW Rivers', id: hoveredRiverId }, { highlight: false });
                    hoveredRiverId = null;
                }
            });


            map.on('mouseenter', 'Lakes-poly', (e) => {
                isHovering.lakes = true;
                updateCursor();

                const feature = e.features[0];
                if (hoveredLakeId !== null && hoveredLakeId !== feature.id) {
                    map.setFeatureState({ source: 'Lakes', id: hoveredLakeId }, { highlight: false });
                }
                hoveredLakeId = feature.id;
                map.setFeatureState({ source: 'Lakes', id: feature.id }, { highlight: true });
            });

            map.on('mouseleave', 'Lakes-poly', () => {
                isHovering.lakes = false;
                updateCursor();

                if (hoveredLakeId !== null) {
                    map.setFeatureState({ source: 'Lakes', id: hoveredLakeId }, { highlight: false });
                    hoveredLakeId = null;
                }
            });

        }

  


document.getElementById('toggle-fg-regions').addEventListener('click', () => {
    const lineLayerId = 'FG Regions-line';
    const labelLayerId = 'FG Region Labels';

    // Check if line layer exists
    if (!map.getLayer(lineLayerId)) {
        console.warn(`Layer "${lineLayerId}" not found.`);
        return;
    }
    // Also check if label layer exists
    if (!map.getLayer(labelLayerId)) {
        console.warn(`Layer "${labelLayerId}" not found.`);
        return;
    }

    // Get current visibility of the line layer (assuming labels match it)
    const visibility = map.getLayoutProperty(lineLayerId, 'visibility');

    if (visibility === 'visible' || visibility === undefined) {
        // Hide both line and labels
        map.setLayoutProperty(lineLayerId, 'visibility', 'none');
        map.setLayoutProperty(labelLayerId, 'visibility', 'none');
        document.getElementById('toggle-fg-regions').textContent = 'Show FG Regions';
    } else {
        // Show both line and labels
        map.setLayoutProperty(lineLayerId, 'visibility', 'visible');
        map.setLayoutProperty(labelLayerId, 'visibility', 'visible');
        document.getElementById('toggle-fg-regions').textContent = 'Hide FG Regions';
    }
});




        function updateRiverFilter() {
            const checked = Array.from(document.querySelectorAll('#method-filters input:checked'))
                .map(input => input.value.toLowerCase());

            const noFilter = ['==', 'fly', -1];  // Always false filter

            if (map.getLayer('AW Rivers-line')) {
                if (checked.length === 0) {
                    map.setFilter('AW Rivers-line', noFilter);
                } else {
                    const filter = ['any', ...checked.map(method => ['==', ['get', method], 1])];
                    map.setFilter('AW Rivers-line', filter);
                }
            }

            if (map.getLayer('Lakes-poly')) {
                if (checked.length === 0) {
                    map.setFilter('Lakes-poly', noFilter);
                } else {
                    const filter = ['any', ...checked.map(method => ['==', ['get', method], 1])];
                    map.setFilter('Lakes-poly', filter);
                }
            }
        }

        // Add event listeners to checkboxes
        document.querySelectorAll('#method-filters input').forEach(input => {
            input.addEventListener('change', updateRiverFilter);
        });

        // Call it once to set initial filter
        map.on('load', () => {
            updateRiverFilter();
        });


        const layerList = document.getElementById('menu');
        const inputs = layerList.getElementsByTagName('input');

        for (const input of inputs) {
            input.onclick = (layer) => {
                const styleId = `mapbox://styles/mapbox/${layer.target.id}`;
                map.setStyle(styleId);
            };
        }


        function toggleFilters() {
            const filterBox = document.getElementById('combined-filters');
            const button = event.target;
            if (filterBox.style.display === 'none') {
                filterBox.style.display = 'block';
                button.textContent = 'Hide Filters';
            } else {
                filterBox.style.display = 'none';
                button.textContent = 'Show Filters';
            }
        }
        (function enableResizing() {
            let startY = 0;
            let startHeight = 0;
            const card = document.getElementById('properties');

            document.addEventListener('mousedown', startDrag);
            document.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                const target = e.target.closest('.map-overlay-drag-handle');
                if (!target) return;

                e.preventDefault();
                startY = e.touches ? e.touches[0].clientY : e.clientY;

                const overlay = target.closest('.map-overlay-inner');
                startHeight = overlay.offsetHeight;

                document.addEventListener('mousemove', onDrag);
                document.addEventListener('touchmove', onDrag, { passive: false });

                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchend', stopDrag);
            }

            function onDrag(e) {
                e.preventDefault();
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                const deltaY = startY - currentY;

                const overlay = document.querySelector('.map-overlay-inner');
                let newHeight = startHeight + deltaY;

                // Clamp the height between 30% and 90% of viewport height
                const minHeight = window.innerHeight * 0.3;
                const maxHeight = window.innerHeight * 0.9;
                newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));

                overlay.style.height = `${newHeight}px`;
            }

            function stopDrag() {
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
            }
        })();
        const hydroButton = document.createElement('button');
        hydroButton.textContent = 'Load Local Hydro Parcels';
        hydroButton.className = 'hydro-button'; // use CSS class
        hydroButton.style.display = 'none'; // still hide initially


        // Add the button to the map container
        map.getContainer().appendChild(hydroButton);

        map.on('moveend', () => {
            const zoom = map.getZoom();
            hydroButton.style.display = zoom >= 15 ? 'block' : 'none';
        });

        hydroButton.addEventListener('click', () => {
            const center = map.getCenter();
            const lat = center.lat;
            const lng = center.lng;

            // URLs for hydro parcels, road parcels, and DOC areas
            const hydroUrl = `https://data.linz.govt.nz/services/query/v1/vector.json?key=70df4e2427df4763855d3db1c55bc2ce&layer=50771&x=${lng}&y=${lat}&max_results=100&radius=500&geometry=true&with_field_names=true`;
            const roadUrl = `https://data.linz.govt.nz/services/query/v1/vector.json?key=70df4e2427df4763855d3db1c55bc2ce&layer=50796&x=${lng}&y=${lat}&max_results=100&radius=500&geometry=true&with_field_names=true`;
            const privateUrl = `https://data.linz.govt.nz/services/query/v1/vector.json?key=70df4e2427df4763855d3db1c55bc2ce&layer=50804&x=${lng}&y=${lat}&max_results=100&radius=500&geometry=true&with_field_names=true`;

            // Fetch all three layers in parallel
            Promise.all([fetch(hydroUrl), fetch(roadUrl), fetch(privateUrl)])
                .then(responses => Promise.all(responses.map(r => r.json())))
                .then(([hydroData, roadData, privateData]) => {
                    const hydroFeatures = hydroData.vectorQuery?.layers?.['50771']?.features || [];
                    const roadFeatures = roadData.vectorQuery?.layers?.['50796']?.features || [];
                    const privateFeatures = privateData.vectorQuery?.layers?.['50804']?.features || [];

                    if (hydroFeatures.length === 0) console.log("No hydro parcel data found.");
                    if (roadFeatures.length === 0) console.log("No road parcel data found.");
                    if (privateFeatures.length === 0) console.log("No private area data found.");

                    const hydroGeoJSON = {
                        type: "FeatureCollection",
                        features: hydroFeatures.map(f => ({
                            type: "Feature",
                            geometry: f.geometry,
                            properties: f.properties
                        }))
                    };

                    const roadGeoJSON = {
                        type: "FeatureCollection",
                        features: roadFeatures.map(f => ({
                            type: "Feature",
                            geometry: f.geometry,
                            properties: f.properties
                        }))
                    };

                    const privateGeoJSON = {
                        type: "FeatureCollection",
                        features: privateFeatures.map(f => ({
                            type: "Feature",
                            geometry: f.geometry,
                            properties: f.properties
                        }))
                    };

                    // Hydro layer
                    if (map.getSource('hydro')) {
                        map.getSource('hydro').setData(hydroGeoJSON);
                    } else {
                        map.addSource('hydro', { type: 'geojson', data: hydroGeoJSON });
                        map.addLayer({
                            id: 'hydro-layer',
                            type: 'fill',
                            source: 'hydro',
                            paint: {
                                'fill-color': 'pink',
                                'fill-opacity': 0.7
                            }
                        });
                    }

                    // Road layer
                    if (map.getSource('road')) {
                        map.getSource('road').setData(roadGeoJSON);
                    } else {
                        map.addSource('road', { type: 'geojson', data: roadGeoJSON });
                        map.addLayer({
                            id: 'road-layer',
                            type: 'fill',
                            source: 'road',
                            paint: {
                                'fill-color': 'pink',
                                'fill-opacity': 0.7
                            }
                        });
                    }

                    // private layer
                    if (map.getSource('private')) {
                        map.getSource('private').setData(privateGeoJSON);
                    } else {
                        map.addSource('private', { type: 'geojson', data: privateGeoJSON });
                        map.addLayer({
                            id: 'private-layer',
                            type: 'fill',
                            source: 'private',
                            paint: {
                                'fill-color': 'red',
                                'fill-opacity': 0.5
                            }
                        });
                    }
                })
                .catch(error => console.error("Error fetching spatial data:", error));
        });




    </script>

</body>

</html>